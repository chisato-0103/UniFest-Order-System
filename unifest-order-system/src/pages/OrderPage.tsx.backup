// ğŸ›’ ãŠå®¢ã•ã‚“ãŒæ³¨æ–‡ã™ã‚‹ãƒšãƒ¼ã‚¸
// ãŸã“ç„¼ãã‚„ãƒˆãƒƒãƒ”ãƒ³ã‚°ã‚’é¸ã‚“ã§ã€ã‚«ãƒ¼ãƒˆã«å…¥ã‚Œã¦æ³¨æ–‡ã§ãã¾ã™
// ä¾‹ï¼šãŸã“ç„¼ã8å€‹ + ãƒãƒ¨ãƒãƒ¼ã‚º + é’ã®ã‚Š = 600å††

import { useState, useEffect } from "react"; // Reactã®åŸºæœ¬æ©Ÿèƒ½
import { useNavigate } from "react-router-dom"; // ãƒšãƒ¼ã‚¸ç§»å‹•æ©Ÿèƒ½
import {
  Typography, // æ–‡å­—ã‚’è¡¨ç¤ºã™ã‚‹éƒ¨å“
  Box, // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ã®ç®±
  Card, // ã‚«ãƒ¼ãƒ‰è¡¨ç¤º
  CardContent, // ã‚«ãƒ¼ãƒ‰ã®ä¸­èº«
  Button, // ãƒœã‚¿ãƒ³
  Badge, // ãƒãƒƒã‚¸ï¼ˆæ•°å­—ã‚’è¡¨ç¤ºï¼‰
  Chip, // å°ã•ãªã‚¿ã‚°
  Fab, // æµ®ã„ã¦ã„ã‚‹ãƒœã‚¿ãƒ³ï¼ˆã‚«ãƒ¼ãƒˆãƒœã‚¿ãƒ³ï¼‰
  Dialog, // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ç”»é¢
  DialogTitle, // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¿ã‚¤ãƒˆãƒ«
  DialogContent, // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ä¸­èº«
  DialogActions, // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒœã‚¿ãƒ³
  List, // ãƒªã‚¹ãƒˆè¡¨ç¤º
  ListItem, // ãƒªã‚¹ãƒˆã®é …ç›®
  ListItemText, // ãƒªã‚¹ãƒˆé …ç›®ã®ãƒ†ã‚­ã‚¹ãƒˆ
  ListItemSecondaryAction, // ãƒªã‚¹ãƒˆé …ç›®ã®å³å´
  Alert, // è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  FormGroup, // ãƒ•ã‚©ãƒ¼ãƒ ã®ã‚°ãƒ«ãƒ¼ãƒ—
  FormControlLabel, // ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ©ãƒ™ãƒ«
  Checkbox, // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
  Divider, // åŒºåˆ‡ã‚Šç·š
} from "@mui/material";
import {
  ShoppingCart as CartIcon, // ã‚«ãƒ¼ãƒˆã‚¢ã‚¤ã‚³ãƒ³
  Warning as WarningIcon, // è­¦å‘Šã‚¢ã‚¤ã‚³ãƒ³
} from "@mui/icons-material";
import { useAppContext } from "../hooks/useAppContext"; // ã‚¢ãƒ—ãƒªã®çŠ¶æ…‹ã‚’ä½¿ã†é“å…·
import OrderCompletionDialog from "../components/OrderCompletionDialog"; // æ³¨æ–‡å®Œäº†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
import PageLayout from "../components/PageLayout"; // ãƒšãƒ¼ã‚¸ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
import CustomerNavigationBar from "../components/CustomerNavigationBar"; // ãŠå®¢ã•ã‚“ç”¨ãƒŠãƒ“ãƒãƒ¼
import type { Product, Topping, CartItem } from "../types"; // ãƒ‡ãƒ¼ã‚¿ã®å‹
import {
  ProductService,
  FALLBACK_DATA,
  ApiError,
} from "../services/apiService"; // çµ±ä¸€APIé€šä¿¡ã‚µãƒ¼ãƒ“ã‚¹
  description: string; // èª¬æ˜
  available: boolean; // æ³¨æ–‡ã§ãã‚‹ã‹ã©ã†ã‹
}

// ğŸ¯ ç°¡å˜ãªãƒˆãƒƒãƒ”ãƒ³ã‚°æƒ…å ±ã®å½¢
interface SimpleTopping {
  id: string; // ãƒˆãƒƒãƒ”ãƒ³ã‚°ç•ªå·
  name: string; // ãƒˆãƒƒãƒ”ãƒ³ã‚°åï¼ˆä¾‹ï¼šãƒãƒ¨ãƒãƒ¼ã‚ºï¼‰
  price: number; // å€¤æ®µ
  available: boolean;
}

// ğŸ“¦ ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼ˆAPIæ¥ç¶šã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰

const dummyProducts: SimpleProduct[] = [
  {
    id: "1",
    name: "ãŸã“ç„¼ã 6å€‹å…¥ã‚Š",
    price: 500,
    category: "ãƒ¡ã‚¤ãƒ³",
    description: "å®šç•ªã®6å€‹å…¥ã‚ŠãŸã“ç„¼ãã§ã™",
    available: true,
  },
  {
    id: "2",
    name: "ãŸã“ç„¼ã 8å€‹å…¥ã‚Š",
    price: 650,
    category: "ãƒ¡ã‚¤ãƒ³",
    description: "ãŠå¾—ãª8å€‹å…¥ã‚ŠãŸã“ç„¼ãã§ã™",
    available: true,
  },
  {
    id: "3",
    name: "ç‰¹è£½ãŸã“ç„¼ã 6å€‹å…¥ã‚Š",
    price: 700,
    category: "ç‰¹è£½",
    description: "ç‰¹è£½ã ã—å…¥ã‚Šã®ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãŸã“ç„¼ã",
    available: true,
  },
  {
    id: "4",
    name: "ãŸã“ç„¼ãã‚»ãƒƒãƒˆ",
    price: 800,
    category: "ã‚»ãƒƒãƒˆ",
    description: "ãŸã“ç„¼ã6å€‹ï¼‹ãƒ‰ãƒªãƒ³ã‚¯",
    available: false,
  },
];

const dummyToppings: SimpleTopping[] = [
  { id: "1", name: "ã‚½ãƒ¼ã‚¹", price: 0, available: true },
  { id: "2", name: "ãƒãƒ¨ãƒãƒ¼ã‚º", price: 0, available: true },
  { id: "3", name: "é’ã®ã‚Š", price: 50, available: true },
  { id: "4", name: "ã‹ã¤ãŠç¯€", price: 50, available: true },
  { id: "5", name: "ãƒãƒ¼ã‚º", price: 100, available: true },
  { id: "6", name: "æ˜å¤ªå­", price: 150, available: true },
];

function OrderPage() {
  const navigate = useNavigate(); // ãƒšãƒ¼ã‚¸ç§»å‹•æ©Ÿèƒ½
  const { state, dispatch } = useAppContext(); // dispatch ã‚’è¿½åŠ 
  const { systemState, connectionStatus, cart: appCart } = state; // AppContextã®ã‚«ãƒ¼ãƒˆã‚’å–å¾—

  // å•†å“ãƒ‡ãƒ¼ã‚¿ã®çŠ¶æ…‹ç®¡ç†
  const [products, setProducts] = useState<Product[]>([]);
  const [toppings, setToppings] = useState<Topping[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>("");

  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [selectedToppings, setSelectedToppings] = useState<Topping[]>([]);
  const [cartDialogOpen, setCartDialogOpen] = useState(false);
  const [productDialogOpen, setProductDialogOpen] = useState(false);
  const [orderCompletionOpen, setOrderCompletionOpen] = useState(false);
  const [completedOrder] = useState<Order | null>(null); // ä½¿ç”¨ã—ãªã„ãŒãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®propsã§å¿…è¦
  const [estimatedTime] = useState(10); // ä½¿ç”¨ã—ãªã„ãŒãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®propsã§å¿…è¦

  // ğŸŒ çµ±ä¸€ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿å–å¾—å‡¦ç†
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError("");

        if (!navigator.onLine) {
          throw new ApiError("ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“");
        }

        // ğŸ“¦ å•†å“ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const productsData = await ProductService.getProducts();
        setProducts(productsData);

        // ğŸ¯ ãƒˆãƒƒãƒ”ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const toppingsData = await ProductService.getToppings();
        setToppings(toppingsData);

      } catch (err: unknown) {
        console.error("ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:", err);

        let errorMessage = "ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ";
        if (err instanceof ApiError) {
          errorMessage = err.message;
        } else if (err instanceof Error) {
          if (err.name === "AbortError") {
            errorMessage = "é€šä¿¡ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ";
          } else if (err.message.includes("Failed to fetch")) {
            errorMessage = "ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“";
          } else {
            errorMessage = err.message;
          }
        }

        setError(errorMessage);

        // ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
        setProducts(FALLBACK_DATA.products);
        setToppings(FALLBACK_DATA.toppings);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []); {
              "Cache-Control": "no-cache",
            },
          }
        );

        clearTimeout(timeoutId);

        if (!productsResponse.ok) {
          if (productsResponse.status === 503) {
            throw new Error("ã‚µãƒ¼ãƒãƒ¼ãŒãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ä¸­ã§ã™");
          } else if (productsResponse.status >= 500) {
            throw new Error("ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
          } else if (productsResponse.status === 404) {
            throw new Error("å•†å“ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
          }
          throw new Error("å•†å“ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ");
        }

        const productsData = await productsResponse.json();

        if (!productsData.success || !Array.isArray(productsData.data)) {
          throw new Error("å•†å“ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“");
        }

        // APIãƒ‡ãƒ¼ã‚¿ã‚’SimpleProductå½¢å¼ã«å¤‰æ›
        const formattedProducts: SimpleProduct[] = productsData.data.map(
          (product: {
            product_id: number;
            product_name: string;
            price: string;
            category_name?: string;
            description?: string;
            status: string;
            stock_quantity: number;
            available_toppings?: Array<{
              topping_id: number;
              topping_name: string;
              price: number;
            }>;
          }) => ({
            id: product.product_id.toString(),
            name: product.product_name,
            price: parseFloat(product.price),
            category: product.category_name || "ãƒ¡ã‚¤ãƒ³",
            description: product.description || `${product.product_name}ã§ã™`,
            available: product.status === "æœ‰åŠ¹" && product.stock_quantity > 0,
          })
        );

        setProducts(formattedProducts);

        // ãƒˆãƒƒãƒ”ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæœ€åˆã®å•†å“ã‹ã‚‰ï¼‰
        if (
          productsData.data.length > 0 &&
          productsData.data[0].available_toppings
        ) {
          const formattedToppings: SimpleTopping[] =
            productsData.data[0].available_toppings.map(
              (topping: {
                topping_id: number;
                topping_name: string;
                price: number;
              }) => ({
                id: topping.topping_id.toString(),
                name: topping.topping_name,
                price: topping.price,
                available: true,
              })
            );
          setToppings(formattedToppings);
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒˆãƒƒãƒ”ãƒ³ã‚°
          setToppings(dummyToppings);
        }
      } catch (err: unknown) {
        console.error("APIå–å¾—ã‚¨ãƒ©ãƒ¼:", err);

        let errorMessage = "å•†å“ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ";
        if (err instanceof Error) {
          if (err.name === "AbortError") {
            errorMessage = "é€šä¿¡ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ";
          } else if (err.message.includes("Failed to fetch")) {
            errorMessage = "ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“";
          } else if (err.message) {
            errorMessage = err.message;
          }
        }

        setError(errorMessage);

        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
        setProducts(dummyProducts);
        setToppings(dummyToppings);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  const handleProductClick = (product: SimpleProduct) => {
    if (!product.available) return;
    setSelectedProduct(product);
    setSelectedToppings([]);
    setProductDialogOpen(true);
  };

  const handleToppingToggle = (topping: SimpleTopping) => {
    setSelectedToppings((prev) => {
      const exists = prev.find((t) => t.id === topping.id);
      if (exists) {
        return prev.filter((t) => t.id !== topping.id);
      } else {
        return [...prev, topping];
      }
    });
  };

  const handleAddToCart = () => {
    if (!selectedProduct) return;

    // ï¿½ SimpleProductã‚’Productå‹ã«å¤‰æ›
    const productForCart: Product = {
      id: selectedProduct.id,
      product_id: selectedProduct.id,
      name: selectedProduct.name,
      product_name: selectedProduct.name,
      price: selectedProduct.price,
      category: selectedProduct.category,
      description: selectedProduct.description,
      available: selectedProduct.available,
    };

    // ğŸ”„ SimpleToppingã‚’Toppingå‹ã«å¤‰æ›
    const toppingsForCart: Topping[] = selectedToppings.map((topping) => ({
      id: topping.id,
      topping_id: topping.id,
      name: topping.name,
      topping_name: topping.name,
      price: topping.price,
      available: topping.available,
    }));

    // ï¿½ğŸ›’ AppContextã®ã‚«ãƒ¼ãƒˆã«å•†å“ã‚’è¿½åŠ 
    dispatch({
      type: "ADD_TO_CART",
      payload: {
        product: productForCart,
        quantity: 1,
        toppings: toppingsForCart,
      },
    });

    setProductDialogOpen(false);
    setSelectedProduct(null);
    setSelectedToppings([]);
  };

  // ğŸ”§ å•†å“ã¨ãƒˆãƒƒãƒ”ãƒ³ã‚°ã®åˆè¨ˆä¾¡æ ¼ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
  const calculateItemPrice = (
    product: SimpleProduct,
    toppings: SimpleTopping[]
  ) => {
    return (
      product.price + toppings.reduce((sum, topping) => sum + topping.price, 0)
    );
  };

  // å–¶æ¥­çŠ¶æ³ã«å¿œã˜ãŸè¡¨ç¤ºåˆ¶å¾¡
  const isOrderingAvailable =
    systemState.å–¶æ¥­çŠ¶æ³ === "å–¶æ¥­ä¸­" && !systemState.ç·Šæ€¥åœæ­¢çŠ¶æ…‹;

  return (
    <>
      <CustomerNavigationBar title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼" />
      <PageLayout maxWidth="xl">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Box sx={{ mb: 3 }}>
          <Typography variant="h4" component="h1" gutterBottom color="primary">
            æ³¨æ–‡ç”»é¢
          </Typography>
          <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap", mb: 2 }}>
            <Chip
              label={systemState.å–¶æ¥­çŠ¶æ³}
              color={systemState.å–¶æ¥­çŠ¶æ³ === "å–¶æ¥­ä¸­" ? "success" : "warning"}
              variant="filled"
            />
            <Chip
              label={systemState.æ··é›‘çŠ¶æ³}
              color={
                systemState.æ··é›‘çŠ¶æ³ === "æ··é›‘"
                  ? "error"
                  : systemState.æ··é›‘çŠ¶æ³ === "æ™®é€š"
                  ? "warning"
                  : "success"
              }
              variant="outlined"
            />
            {systemState.å¾…ã¡ä»¶æ•° > 0 && (
              <Chip
                label={`å¾…ã¡æ™‚é–“: ç´„${systemState.å¾…ã¡ä»¶æ•° * 8}åˆ†`}
                color="info"
                variant="outlined"
              />
            )}
          </Box>

          {!isOrderingAvailable && (
            <Alert severity="warning" sx={{ mb: 2 }}>
              <Typography variant="body1" sx={{ fontWeight: "bold" }}>
                ç¾åœ¨æ³¨æ–‡ã‚’å—ã‘ä»˜ã‘ã¦ã„ã¾ã›ã‚“
              </Typography>
              <Typography variant="body2">
                {systemState.å–¶æ¥­çŠ¶æ³ === "æº–å‚™ä¸­" &&
                  "å–¶æ¥­æº–å‚™ä¸­ã§ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚"}
                {systemState.å–¶æ¥­çŠ¶æ³ === "å–¶æ¥­çµ‚äº†" &&
                  "æœ¬æ—¥ã®å–¶æ¥­ã¯çµ‚äº†ã„ãŸã—ã¾ã—ãŸã€‚"}
                {systemState.ç·Šæ€¥åœæ­¢çŠ¶æ…‹ && "ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ä¸­ã§ã™ã€‚"}
              </Typography>
            </Alert>
          )}

          {connectionStatus !== "connected" && (
            <Alert severity="error" sx={{ mb: 2 }}>
              ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚æ³¨æ–‡æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ããªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
            </Alert>
          )}
        </Box>

        {/* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */}
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º */}
        {loading && (
          <Box sx={{ display: "flex", justifyContent: "center", my: 4 }}>
            <Typography>å•†å“ã‚’èª­ã¿è¾¼ã¿ä¸­...</Typography>
          </Box>
        )}

        {/* å•†å“ä¸€è¦§ */}
        {!loading && (
          <Box
            sx={{
              display: "grid",
              gridTemplateColumns: {
                xs: "1fr", // ã‚¹ãƒãƒ›: 1åˆ—
                sm: "repeat(2, 1fr)", // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ: 2åˆ—
                md: "repeat(3, 1fr)", // PC: 3åˆ—
                lg: "repeat(4, 1fr)", // å¤§ç”»é¢: 4åˆ—
              },
              gap: 3,
              mb: 8,
            }}
          >
            {products.map((product) => (
              <Card
                key={product.id}
                sx={{
                  height: "100%",
                  display: "flex",
                  flexDirection: "column",
                  opacity: !product.available || !isOrderingAvailable ? 0.6 : 1,
                  cursor:
                    product.available && isOrderingAvailable
                      ? "pointer"
                      : "default",
                  transition: "all 0.2s ease-in-out",
                  "&:hover":
                    product.available && isOrderingAvailable
                      ? {
                          boxShadow: 4,
                          transform: "translateY(-2px)",
                        }
                      : {},
                }}
                onClick={() =>
                  product.available &&
                  isOrderingAvailable &&
                  handleProductClick(product)
                }
              >
                <CardContent
                  sx={{
                    flexGrow: 1,
                    display: "flex",
                    flexDirection: "column",
                    p: 2,
                  }}
                >
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "flex-start",
                      mb: 1,
                    }}
                  >
                    <Typography
                      variant="h6"
                      component="h2"
                      color="primary"
                      sx={{
                        fontSize: { xs: "1rem", sm: "1.1rem" },
                        fontWeight: "bold",
                        lineHeight: 1.3,
                      }}
                    >
                      {product.name}
                    </Typography>
                    <Chip
                      label={product.category}
                      size="small"
                      color="secondary"
                      variant="outlined"
                      sx={{ ml: 1, flexShrink: 0 }}
                    />
                  </Box>

                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{
                      mb: 2,
                      flexGrow: 1,
                      fontSize: { xs: "0.8rem", sm: "0.875rem" },
                    }}
                  >
                    {product.description}
                  </Typography>

                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      mt: "auto",
                    }}
                  >
                    <Typography
                      variant="h5"
                      color="primary"
                      sx={{
                        fontWeight: "bold",
                        fontSize: { xs: "1.2rem", sm: "1.5rem" },
                      }}
                    >
                      Â¥{product.price.toLocaleString()}
                    </Typography>

                    <Box
                      sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-end",
                        gap: 0.5,
                      }}
                    >
                      {!product.available && (
                        <Chip
                          label="å£²ã‚Šåˆ‡ã‚Œ"
                          color="error"
                          size="small"
                          icon={<WarningIcon />}
                        />
                      )}

                      {product.available && !isOrderingAvailable && (
                        <Chip label="æ³¨æ–‡åœæ­¢ä¸­" color="warning" size="small" />
                      )}
                    </Box>
                  </Box>
                </CardContent>
              </Card>
            ))}
          </Box>
        )}

        {/* ã‚«ãƒ¼ãƒˆ FAB */}
        {appCart.items.length > 0 && (
          <Fab
            color="primary"
            aria-label="cart"
            sx={{
              position: "fixed",
              bottom: 24,
              right: 24,
              zIndex: 1000,
            }}
            onClick={() => setCartDialogOpen(true)}
          >
            <Badge badgeContent={appCart.items.length} color="error">
              <CartIcon />
            </Badge>
          </Fab>
        )}

        {/* å•†å“é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
        <Dialog
          open={productDialogOpen}
          onClose={() => setProductDialogOpen(false)}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>{selectedProduct?.name}</DialogTitle>
          <DialogContent>
            {selectedProduct && (
              <Box>
                <Typography
                  variant="body1"
                  color="text.secondary"
                  sx={{ mb: 2 }}
                >
                  {selectedProduct.description}
                </Typography>

                <Typography variant="h6" color="primary" sx={{ mb: 2 }}>
                  åŸºæœ¬ä¾¡æ ¼: Â¥{selectedProduct.price.toLocaleString()}
                </Typography>

                <Divider sx={{ my: 2 }} />

                <Typography variant="h6" sx={{ mb: 2 }}>
                  ãƒˆãƒƒãƒ”ãƒ³ã‚°é¸æŠ
                </Typography>

                <FormGroup>
                  {toppings
                    .filter((t) => t.available)
                    .map((topping) => (
                      <FormControlLabel
                        key={topping.id}
                        control={
                          <Checkbox
                            checked={selectedToppings.some(
                              (t) => t.id === topping.id
                            )}
                            onChange={() => handleToppingToggle(topping)}
                          />
                        }
                        label={
                          <Box
                            sx={{
                              display: "flex",
                              justifyContent: "space-between",
                              width: "100%",
                            }}
                          >
                            <span>{topping.name}</span>
                            <span>
                              {topping.price > 0
                                ? `+Â¥${topping.price}`
                                : "ç„¡æ–™"}
                            </span>
                          </Box>
                        }
                      />
                    ))}
                </FormGroup>

                <Divider sx={{ my: 2 }} />

                <Typography variant="h6" color="primary">
                  åˆè¨ˆ: Â¥
                  {calculateItemPrice(
                    selectedProduct,
                    selectedToppings
                  ).toLocaleString()}
                </Typography>
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setProductDialogOpen(false)}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </Button>
            <Button onClick={handleAddToCart} variant="contained">
              ã‚«ãƒ¼ãƒˆã«è¿½åŠ 
            </Button>
          </DialogActions>
        </Dialog>

        {/* ã‚«ãƒ¼ãƒˆãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
        <Dialog
          open={cartDialogOpen}
          onClose={() => setCartDialogOpen(false)}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>æ³¨æ–‡å†…å®¹ç¢ºèª</DialogTitle>
          <DialogContent>
            {appCart.items.length === 0 ? (
              <Typography variant="body1" color="text.secondary">
                ã‚«ãƒ¼ãƒˆã¯ç©ºã§ã™
              </Typography>
            ) : (
              <List>
                {appCart.items.map((item, index) => (
                  <ListItem key={index} divider>
                    <ListItemText
                      primary={item.name}
                      secondary={
                        <Box>
                          {item.toppings && item.toppings.length > 0 && (
                            <Typography variant="body2" color="text.secondary">
                              ãƒˆãƒƒãƒ”ãƒ³ã‚°:{" "}
                              {item.toppings.map((t) => t.name).join(", ")}
                            </Typography>
                          )}
                          <Typography variant="body2" color="primary">
                            Â¥{item.price.toLocaleString()} Ã— {item.quantity}
                          </Typography>
                        </Box>
                      }
                    />
                    <ListItemSecondaryAction>
                      <Box
                        sx={{ display: "flex", alignItems: "center", gap: 1 }}
                      >
                        <Typography variant="body1" sx={{ minWidth: 40 }}>
                          {item.quantity}
                        </Typography>
                      </Box>
                    </ListItemSecondaryAction>
                  </ListItem>
                ))}
              </List>
            )}

            {appCart.items.length > 0 && (
              <Box sx={{ mt: 2, p: 2, bgcolor: "grey.100", borderRadius: 2 }}>
                <Typography
                  variant="h5"
                  color="primary"
                  sx={{ fontWeight: "bold" }}
                >
                  åˆè¨ˆé‡‘é¡: Â¥{appCart.total.toLocaleString()}
                </Typography>
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setCartDialogOpen(false)}>é–‰ã˜ã‚‹</Button>
            {appCart.items.length > 0 && (
              <Button
                onClick={() => navigate("/cart")}
                variant="contained"
                color="primary"
              >
                ã‚«ãƒ¼ãƒˆã¸ç§»å‹•
              </Button>
            )}
          </DialogActions>
        </Dialog>

        {/* æ³¨æ–‡å®Œäº†ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
        <OrderCompletionDialog
          open={orderCompletionOpen}
          onClose={() => setOrderCompletionOpen(false)}
          order={completedOrder}
          estimatedTime={estimatedTime}
        />
      </PageLayout>
    </>
  );
}

export default OrderPage;
